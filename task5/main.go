/*
Разработать программу, которая будет последовательно отправлять значения в канал, а с другой стороны канала — читать.
По истечению N секунд программа должна завершаться.
*/
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	first()
	second()
}

func first() {

	sec := 0

	fmt.Print("Укажите через сколько секунд первая программа должна завершиться: ")
	fmt.Scan(&sec)

	// создаем канал куда будем записывать значения
	ch := make(chan int)

	// создаем таймер на определенное кол-во секунд которое указал пользователь после которого программа остановиться
	tm := time.After(time.Duration(sec) * time.Second)
	go func() {
		for {
			select {
			// если время вышло то закрываем канал и выходим
			case <-tm:
				fmt.Println("Первая программа завершилась...")
				close(ch)
				return
			// записываем случайные числа в канал
			case ch <- rand.Int():
			}
		}
	}()

	// читаем из канала
	for i := range ch {
		fmt.Println(i)
	}

}

func second() {
	sec := 0

	fmt.Print("Укажите через сколько секунд вторая программа должна завершиться: ")
	fmt.Scan(&sec)

	// создаем канал куда будем записывать значения
	ch := make(chan int)
	done := make(chan struct{})

	/* запускаем отдельную горутину в которой будем засыпать на определенное кол-во секунд
	и запишем в канал done который будет сигнализировать о завершении программы */
	go func() {
		time.Sleep(time.Duration(sec) * time.Second)
		done <- struct{}{}
	}()

	// запускаем горутину в которой в бесконечном цикле будем отправлять случайные числа и ждать пока в канал done не запишеться значение
	go func() {
		for {
			select {
			case <-done:
				fmt.Println("Вторая программа завершилась...")
				close(ch)
				return
			default:
				ch <- rand.Int()
			}
		}
	}()

	// читаем из канала
	for i := range ch {
		fmt.Println(i)
	}

}
